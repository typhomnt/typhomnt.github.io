<!DOCTYPE html><html lang="en-us" >

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.8.0">

  

  
  
  
  
  
    
    
    
  
  

  

  
  
  
    
  
  <meta name="description" content="MathJax.Hub.Config({ tex2jax: { inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]], displayMath: [[&#39;$$&#39;,&#39;$$&#39;], [&#39;\[&#39;,&#39;\]&#39;]], processEscapes: true, processEnvironments: true, skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;], TeX: { equationNumbers: { autoNumber: &#34;AMS&#34; }, extensions: [&#34;AMSmath.js&#34;, &#34;AMSsymbols.js&#34;] } } });  MathJax.Hub.Queue(function() { // Fix  tags after MathJax finishes running. This is a // hack to overcome a shortcoming of Markdown. Discussion at // https://github.com/mojombo/jekyll/issues/199 var all = MathJax.Hub.getAllJax(), i; for(i = 0; i  -- This tutorial is inspired from https://learnopengl.">

  
  <link rel="alternate" hreflang="en-us" href="http://typhomnt.github.io/teaching/ray_tracing/pbr_intro/">

  


  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  
  
  <script src="/js/mathjax-config.js"></script>
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-1/css/all.min.css" integrity="sha256-4w9DunooKSr3MFXHXWyFER38WmPdm361bQS/2KUWZbU=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css" integrity="sha256-SHMGCYmST46SoyGgo4YR/9AlK1vf3ff84Aq9yK4hdqM=" crossorigin="anonymous">
    

    

    
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.1.2/lazysizes.min.js" integrity="sha256-Md1qLToewPeKjfAHU1zyPwOutccPAm5tahnaw7Osw0A=" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    

  

  
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap">
  

  
  
  
  
  <link rel="stylesheet" href="/css/academic.css">

  




  


  
  

  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_32x32_fill_box_center_2.png">
  <link rel="apple-touch-icon" type="image/png" href="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_192x192_fill_box_center_2.png">

  <link rel="canonical" href="http://typhomnt.github.io/teaching/ray_tracing/pbr_intro/">

  
  
  
  
  
  
  
    
    
  
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="Maxime Garcia">
  <meta property="og:url" content="http://typhomnt.github.io/teaching/ray_tracing/pbr_intro/">
  <meta property="og:title" content="An Introduction to Physically Based Rendering | Maxime Garcia">
  <meta property="og:description" content="MathJax.Hub.Config({ tex2jax: { inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]], displayMath: [[&#39;$$&#39;,&#39;$$&#39;], [&#39;\[&#39;,&#39;\]&#39;]], processEscapes: true, processEnvironments: true, skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;], TeX: { equationNumbers: { autoNumber: &#34;AMS&#34; }, extensions: [&#34;AMSmath.js&#34;, &#34;AMSsymbols.js&#34;] } } });  MathJax.Hub.Queue(function() { // Fix  tags after MathJax finishes running. This is a // hack to overcome a shortcoming of Markdown. Discussion at // https://github.com/mojombo/jekyll/issues/199 var all = MathJax.Hub.getAllJax(), i; for(i = 0; i  -- This tutorial is inspired from https://learnopengl."><meta property="og:image" content="http://typhomnt.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_box_center_2.png">
  <meta property="twitter:image" content="http://typhomnt.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_box_center_2.png"><meta property="og:locale" content="en-us">
  
    
    
  

  



  


  


  





  <title>An Introduction to Physically Based Rendering | Maxime Garcia</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  







<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">Maxime Garcia</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">Maxime Garcia</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>Home</span></a>
        </li>

        
        

        

        
        
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/post"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#projects"><span>Projects</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/research"><span>Research</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link  active" href="/teaching"><span>Teaching</span></a>
        </li>

        
        

        

        
        
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/art"><span>Art</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#contact"><span>Contact</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      <li class="nav-item dropdown theme-dropdown">
        <a href="#" class="nav-link js-theme-selector" data-toggle="dropdown" aria-haspopup="true">
          <i class="fas fa-palette" aria-hidden="true"></i>
        </a>
        <div class="dropdown-menu">
          <a href="#" class="dropdown-item js-set-theme-light">
            <span>Light</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-dark">
            <span>Dark</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-auto">
            <span>Automatic</span>
          </a>
        </div>
      </li>
      

      

    </ul>

  </div>
</nav>


  <article class="article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1>An Introduction to Physically Based Rendering</h1>

  

  
    


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    Jan 1, 0001
  </span>
  

  

  

  
  
  

  
  

</div>

    














  
</div>



  <div class="article-container">

    <div class="article-style">
      <!--
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    // Fix <code> tags after MathJax finishes running. This is a
    // hack to overcome a shortcoming of Markdown. Discussion at
    // https://github.com/mojombo/jekyll/issues/199
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

-->
<p>This tutorial is inspired from 
<a href="https://learnopengl.com/PBR/Theory" target="_blank" rel="noopener">https://learnopengl.com/PBR/Theory</a> and adapted for the ray-tracing course available 
<a href="../raytracing_practs">here</a>.</p>
<h2 id="introduction-">Introduction</h2>
<p>A big challenge in computer graphics is to design shading models mimicking real-life lighting behaviour while allowing intuitive control of object materials. This control is crucial for artists who are creating assets that have to be integrated in a rendering pipeline. For real-time applications like video games, the question of computation time and memory cost is also essential; such models must be flexible enough and allow affordable approximations.</p>
<p>In this tutorial, we are interested in Physically Based Rendering (PBR) models which aim at simulating light behaviour in a more realistic way, approximating light related equations (models like the Phong model are very simplistic in comparison).
One important aspect of those models is their energy conservative property stating that when interacting with a surface, the amount of outgoing light is equal to the amount of incoming light. More precisely, the amount of light absorbed, scattered and diffused by object surfaces is equal to the amount of light hitting the surface. The figure below illustrates these phenomena.</p>





  











<figure >


  <a data-fancybox="" href="/img/Images/PBR_Intro/LightInteraction.png" >


  <img src="/img/Images/PBR_Intro/LightInteraction.png" alt=""  >
</a>



</figure>

<!-- <p align="center"><img src="/Images/PBR_Intro/LightInteraction.png" alt="LightInteract" style="width:700px;"/></p> -->
<h2 id="surface-representation-micro-facet-model-">Surface Representation: Micro-Facet model</h2>
<p>Simulating this behaviour is highly correlated with how we represent object surfaces. Indeed, light interaction with object surfaces is modeled by the Snell-Descartes law which describes how incident light gets refracted and reflected on a flat surface.</p>





  











<figure >


  <a data-fancybox="" href="/img/Images/PBR_Intro/snelldescartes.png" >


  <img src="/img/Images/PBR_Intro/snelldescartes.png" alt=""  >
</a>



</figure>

<!-- <p align="center"> <img src="/Images/PBR_Intro/snelldescartes.png" alt="SnellDescartes" style="width:700px;"/></p> -->
<p>However, in practice object surfaces are not completely flat, some are rougher than others. This is something noticeable in real life, especially when you look at specular reflection on different objects. More precisely, rough surfaces tend to produce blurred reflections while smooth surfaces behave like mirrors.</p>
<table>
<thead>
<tr>
<th align="center">Rough Surface</th>
<th align="center">Smooth Surface</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">




  











<figure id="figure-rough-surface">


  <a data-fancybox="" href="/img/Images/PBR_Intro/rough_photo.png" data-caption="Rough Surface">


  <img src="/img/Images/PBR_Intro/rough_photo.png" alt="" width="300px" >
</a>


  
  
  <figcaption>
    Rough Surface
  </figcaption>


</figure>
</td>
<td align="center">




  











<figure id="figure-smooth-surface">


  <a data-fancybox="" href="/img/Images/PBR_Intro/smooth_photo.png" data-caption="Smooth Surface">


  <img src="/img/Images/PBR_Intro/smooth_photo.png" alt="" width="300px" >
</a>


  
  
  <figcaption>
    Smooth Surface
  </figcaption>


</figure>
</td>
</tr>
</tbody>
</table>
<p>Thus, the microfacet model was introduced and defines a surface by a continuous sequence of flat micro-surfaces that might be oriented differently, simulating the smooth vs rough aspect of macro-surfaces. The roughness property of a material plays a meaningful role in light behavior as it controls the amount of light that gets reflected and refracted as well as the direction of outgoing light.</p>
<table>
<thead>
<tr>
<th align="center">Rough Surface</th>
<th align="center">Smooth Surface</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img src="/Images/PBR_Intro/roughsurface.png" alt=""></td>
<td align="center"><img src="/Images/PBR_Intro/smoothsurface.png" alt=""></td>
</tr>
</tbody>
</table>
<h2 id="light-equation-">Light Equation</h2>
<p>Having stated all this principles, our main goal remains unchanged, compute the color received by the eye (camera) for each pixel of the output image displayed on our screen. More specifically, we are interested in the color and intensity of light that either gets directly reflected from the surface to the eye or that gets refracted and then re-emitted by the object through diffusion (considering that all the light that gets absorbed is lost). On the other hand, in this tutorial we neglect the effect of scattering which gives more realistic results (especially useful when rendering skin) but is more costly to compute.</p>





  











<figure >


  <a data-fancybox="" href="/img/Images/PBR_Intro/normalsurface.png" >


  <img src="/img/Images/PBR_Intro/normalsurface.png" alt=""  >
</a>



</figure>

<!-- <p align="center"> <img src="/Images/PBR_Intro/normalsurface.png" alt="NormalSurf" style="width:700px;"/></p> -->
<p>The amount of light that gets into a specific direction from a given point on an object surface is governed by laws of physics and more specifically it is given by the reflectance equation:</p>
<p>$$ L_o(p,v) = \int_A f_r(p,l,v,\alpha_p) L_i(p,l), n \cdot l  ,dl $$</p>
<p>Where $p$ is the point of interest on the object surface (receiving light), $v$ the view direction from $p$ to the eye, $l$ the incident light direction, $\alpha_p$ the surface roughness at point $p$, $L_o$ the output light radiance (stored as a RGB color) perceived by our eye from $p$, $L_i$ the incident light radiance (also stored as a RGB color) gathering at $p$ from direction l, $f_r$ a function controlling the amount of light reflected to direction $v$ with respect to the material property at $p$ and $A$ the hemisphere surrounding $p$ on which we integrate all incoming light directions.</p>





  











<figure >


  <a data-fancybox="" href="/img/Images/PBR_Intro/AreaIntegrate.png" >


  <img src="/img/Images/PBR_Intro/AreaIntegrate.png" alt=""  >
</a>



</figure>

<!-- <p align="center"> <img src="/Images/PBR_Intro/AreaIntegrate.png" alt="AreaInt" style="width:700px;"/></p> -->
<p>In this tutorial, we further restrict incoming light sources to a given number of point light sources. Thus, the integral over $A$ can be transformed into a sum over the different light sources.</p>
<p>$$ L_o(p,v) = \sum_l f_r(p,p-c_l,v,\alpha_p) L_i(p,p-c_l), n \cdot \frac{(c_l-p)}{\left\lVert   c_l - p \right\rVert}  $$</p>
<p>The incoming reflectance $L_i(p,p-c_l)$ equals to the intensity of the light source $I$, multiplied by its color $C$, and weighted by an attenuation factor which depends on the distance to the source.
In our case, we will consider that the intensity of light decrease with the square distance to the source:</p>
<p>$$L_i(p,p-c_l) = \frac{IC}{{\left\lVert p - c_l\right\rVert}^2} $$</p>
<h2 id="the-bidirectional-reflective-distribution-function-brdf-">The Bidirectional Reflective Distribution Function (BRDF)</h2>
<p>The only unknown left is the $f_r$ function that controls the amount of reflected light with respect to materials properties. This function is called a BRDF which stands for Bidirectional Reflective Distribution Function. Several functions were proposed to simulate real-life materials behavior, all of them respect the energy conservation law, meaning that the amount of outgoing light do not exceed the amount of incoming light and above all the later is divided between reflected and refracted light. Another important property of the BRDF functions is that there are intresectly symmetric with respect to incoming and outgoing light because of the principle of reversibility of light.
In our case, we will use the Cook-Torrance BRDF model composed of a diffuse and a specular part:</p>
<p>$$f_r = k_d f_l + k_s f_c$$</p>
<p>where $k_d$ is the amount of refracted light that gets re-emitted and $k_s$ the amount of reflected light with:</p>
<p>$$ k_d = 1 - k_s $$</p>
<p>The $f_{l}$ function is the Lambertian diffusion distribution (which corresponds to the diffuse part of the Phong model). It considers that the diffused light is equally spread on all direcion:
$$ f_l = \frac{C}{\pi} $$
Where C is the albedo of the object surface at point $p$. We can notice that the dot product between the normal and the light direction is done outside this function and is still present in the sum of in going contribution. $\pi$ is a normalization factor which accounts for the fact that we integrate ingoing light over the hemisphere at point $p$.</p>





  











<figure >


  <a data-fancybox="" href="/img/Images/PBR_Intro/diffuse.png" >


  <img src="/img/Images/PBR_Intro/diffuse.png" alt=""  >
</a>



</figure>

<!--  <p align="center"> <img src="/Images/PBR_Intro/diffuse.png" alt="Diffuse" style="width:700px;"/></p> -->
<p>At this point it is important to mention that we must differentiate between two type of material: <strong>metals</strong> and <strong>dielectric</strong> (non metal) materials.
Indeed, while dielectric materials diffuse light, it is not the case of metals that absorb all refracted light. As a consequence, $k_d = 0$ for metals (with $k_s \leq 1$ because light still get refracted).</p>
<p>On the other side the $f_c$ is composed of two terms:</p>
<p>$$f_c = \frac{DG}{4(l \cdot n)(v \cdot n)}$$</p>
<p>with D called the Normal Distribution Function and G the Geometry function. Additionally, $k_s = F$, where $F$ is the Fresnel term describing the amount of light that gets refracted on a more macroscopic scale with respect to the view direction. The Fresnel term results from an equation that is not easy to solve, however it can be approximated using the Fresnel-Schlick approximation:</p>
<p>$$ F_{Schlick}(h, v, F_0) = F_0 + (1 - F_0) (1 - (h \cdot v))^5 $$</p>
<p>With $F_0$ being the base reflectivity of the material and $h = \frac{l + v}{\left\lVert l + v \right\rVert}$ the half vector which corresponds to the normal one facet must have to directly reflect the light into the eye.</p>
<p>This equation tells us that when $h$ and $v$ are perpendicular the amount of reflected light is at its maximum, in other words reflections occurs more at grazing angles. This effect is especially noticeable on puddles or wooden surfaces when looking from a top view or from a grazing angle.</p>





  











<figure >


  <a data-fancybox="" href="/img/Images/PBR_Intro/Fresnel_Photo.png" >


  <img src="/img/Images/PBR_Intro/Fresnel_Photo.png" alt=""  >
</a>



</figure>

<!-- <p align="center"> <img src="/Images/PBR_Intro/Fresnel_Photo.png" alt="FresnelPhoto" style="width:700px;"/></p> -->
<p>$F_0$ is computed as the amount of reflected light at normal incidence where $v$ and $l$ are collinear.
It is important to note that this equation can only be applied to dielectric materials, especially because metallic materials absorb all refracted light. However, as $F_0$ for dielectric materials is usually low and  high for metallic materials, a common approximation is to use a common average $F_0$ for dielectic materials and the metal color as $F_O$ for metallic materials. This is plausible because metallic $F_0$ are tinted and give to metals their color. Furthermore, following the metallic workflow we will consider that being metallic or dielectric is not a binary feature, meaning that one material can be sem-metallic with its metalness varying from $0$ to $1$.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong>  One might notice that $h$ is replaced by $n$ in the original equation. This is perfectly right in a macroscopic point of view. However, in our case we look at reflections in a microscopic scale, meaning that the normal of the surface is determined by microfacet normals. Additionally the only case where the light is reflected into our eye is when $n = h$ which justify our use of h in this case. This property is further used to approximate the BRDF final expression.</p>
</blockquote>





  











<figure id="figure-fresnel-coefficient-length-computed-on-our-test-scene-see-below-the-final-amount-has-been-remapped-for-visualisation-purpose">


  <a data-fancybox="" href="/img/Images/PBR_Intro/Fresnel_Vis.png" data-caption="Fresnel coefficient length computed on our test scene (see below). The final amount has been remapped for visualisation purpose.">


  <img src="/img/Images/PBR_Intro/Fresnel_Vis.png" alt=""  >
</a>


  
  
  <figcaption>
    Fresnel coefficient length computed on our test scene (see below). The final amount has been remapped for visualisation purpose.
  </figcaption>


</figure>

<!--  <div style="width:image width px; font-size:100%; text-align:center;"><p align="center"> <img src="/Images/PBR_Intro/Fresnel_Vis.png" alt="FresnelEg" style="width:700px;"/></p>Fresnel coefficient length computed on our test scene (see below). The final amount has been remapped for visualisation purpose.</div> -->
<p>Let us describe the microfacet model in more details and focus on the roughness parameter that plays a role in the amount of reflected light. More concretely, this parameter describes the amount of micro-facet that are aligned in the same direction; in particular, rough surfaces have a chaotic orientation distribution while smooth surfaces facets are oriented in a single direction (the normal).</p>
<p>As microfacets represent the surface of the object, their orientation directly affects the direction of reflected light.
That&rsquo;s why smooth surfaces typically behave like mirrors while reflections appear blurrier on rough surfaces.</p>
<p>We can now describe the role of the Normal Distribution Function D and the Geometric function G.
D represent the amount of microfacet that are aligned with the half vector $h$. This is the same as computing the amount of reflected light rays that are collinear to the view vector $v$.</p>





  











<figure >


  <a data-fancybox="" href="/img/Images/PBR_Intro/ndf_halfvector.png" >


  <img src="/img/Images/PBR_Intro/ndf_halfvector.png" alt=""  >
</a>



</figure>

<!-- <p align="center"> <img src="/Images/PBR_Intro/ndf_halfvector.png" alt="NDFHalfVector" style="width:700px;"/></p> -->
<p>In our case, we chose the GGX distribution function as NDF:</p>
<p>$$D = NDF_{GGX TR}(n, h, \alpha) = \frac{\alpha^2}{\pi((n \cdot h)^2 (\alpha^2 - 1) + 1)^2}$$</p>





  











<figure id="figure-ggx-normal-distribution-function-computed-on-our-test-scene-with-varying-roughness-left-rough-surface-right-smooth-surface">


  <a data-fancybox="" href="/img/Images/PBR_Intro/NDF_Vis.png" data-caption="GGX Normal Distribution Function computed on our test scene with varying roughness (left: rough surface. right: smooth surface)">


  <img src="/img/Images/PBR_Intro/NDF_Vis.png" alt=""  >
</a>


  
  
  <figcaption>
    GGX Normal Distribution Function computed on our test scene with varying roughness (left: rough surface. right: smooth surface)
  </figcaption>


</figure>

<!-- <div style="width:image width px; font-size:100%; text-align:center;"><p align="center"> <img src="/Images/PBR_Intro/NDF_Vis.png" alt="NDFEg" style="width:700px;"/></p>GGX Normal Distribution Function computed on our test scene with varying roughness (left: rough surface. right: smooth surface) </div> -->
<p>This function behaves like a diract when $\alpha = 0$ (smooth surface) and becomes flatter and flatter when $\alpha$ increases until it reaches a constant function $\frac{1}{\pi}$. That is why this formula produces small rounded highlight on smooth surfaces which are completely spread across the object on rough surfaces.</p>
<p>The Geometric function simulates two phenomena that occurs between micro-facets namely obstruction and shadowing. In the two cases, either the incoming light cannot reach some micro-facets because there are in the shadows of others (shadowing) or reflected light is blocked by other facets (obstruction).</p>
<table>
<thead>
<tr>
<th align="center">Shadowing</th>
<th align="center">Masking</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img src="/Images/PBR_Intro/shadowing.png" alt=""></td>
<td align="center"><img src="/Images/PBR_Intro/masking.png" alt=""></td>
</tr>
</tbody>
</table>
<p>Therefore, some amount of reflected light is &ldquo;lost&rdquo; and this is exactly the information given by the Geometric function. In our case we chose the Schlick-GGX approximation:</p>
<p>$$    G_S(n, v, k) =  \frac{n \cdot v}{(n \cdot v)(1 - k) + k }  $$</p>
<p>Taking into account the two effects:</p>
<p>$$   G(n,v,l,k) =  G_S(n, v, k)  G_S(n, l, k) $$</p>
<p>This function intuitively models the fact that at grazing angle with respect to the normal, either incoming light rays of reflected rays have a chance to collide with other facets. This probability is gets higher when the roughness of the surface increases, which is pretty intuitive because the micro-facet gets more chaotic and do not face a single direction.</p>





  











<figure id="figure-geometry-function-computed-on-our-test-scene-left-rough-surface-right-smooth-surface">


  <a data-fancybox="" href="/img/Images/PBR_Intro/Geometry_Vis.png" data-caption="Geometry function computed on our test scene (left: rough surface. right: smooth surface).">


  <img src="/img/Images/PBR_Intro/Geometry_Vis.png" alt=""  >
</a>


  
  
  <figcaption>
    Geometry function computed on our test scene (left: rough surface. right: smooth surface).
  </figcaption>


</figure>

<!--  <div style="width:image width px; font-size:100%; text-align:center;"><p align="center"> <img src="/Images/PBR_Intro/Geometry_Vis.png" alt="GeometryEg" style="width:700px;"/></p>Geometry function computed on our test scene (left: rough surface. right: smooth surface).</div> -->
<p>In this tutorial we made choices for approximation functions but several others can be found in the literature (see <strong>References</strong> at the bottom of the page), I invite you to take a look at BRDF comparison articles.</p>
<h2 id="coding-time-">Coding Time</h2>
<p>We are now ready to dive into the code. The base code can be found 
<a href="/Files/MSIAM_Code.zip">here</a>.
First, lets go back to our main function. We are working inside a fragment shader displaying a simple quad perfectly fitting our window. For each pixel we cast rays from a virtual camera to the current pixel whose screen coordinates are given by the in variable $fragCoord$.</p>
<pre><code>in vec2 fragCoord;
void main()
{   
    Ray ray = generatePerspectiveRay(fragCoord);
    outColor = vec4(trace(ray),1);
}
</code></pre>
<p>Inside the fragment shader, I passed the view matrix $V$ of the trackball that is available from the transform.py file and used it to move the camera.
Notice the inverse operator applied on V as we want to recover the position of the camera in world space.</p>
<pre><code>uniform mat4 V;
Ray generatePerspectiveRay(in vec2 p)
{
    // p is the current pixel coord, in [-1,1]
    float fov = 30; // Half angle
    float D = 1./tan(radians(fov));
    mat4 inv_view = inverse(V); // Get the matrix of the trackball

    vec3 up = vec3(0,1,0);
    vec3 front = vec3(0,0,-1);
    vec3 right = cross(up,front);
    return  Ray((inv_view*vec4(0,0,-D,1)).xyz,mat3(inv_view)*normalize(p.x*right + p.y*up*aspectRatio + D*front));
}
</code></pre>
<p>Next we declare two new structures: the HitSurface structure containing a ray-scene intersection point, the surface normal at this point as well as its material properties expressed as a PBRMat.
As mentioned above these materials contain roughness and metallic properties. We also add an ambient occlusion property which is used when computing an ambient lighting term in the rendering loop.</p>
<pre><code>struct PBRMat
{
    vec3 color;
    float roughness;
    float metallic;
    float ao;
};

struct HitSurface
{
    vec3 hit_point;
    vec3 normal;
    PBRMat material;
};
</code></pre>
<p>Back to the trace function. We declare $accum$ as the color of the pixel that is incremented at each ray bounce, the $mask$ variable indicates the intensity of the current ray which gradually decrease at each bounce. For each step we compute the intersection between the ray and the objects in the scene and store the nearest intersected object (with a positive distance) in the $io$ variable.</p>
<p>The material used for the intersected object is chosen with respect to its index which is used to sample from an array of materials. We then compute the normal and the local illumination of the object
at the intersection point inside the directIllumination function. The reflection intensity factor $c_{refl}$ is updated inside this function. Note, that the reflected ray origin is slightly shifted in the normal direction to avoid  wrong self intersection. This tip is also applied when computing the shadow ray.</p>
<pre><code>vec3 trace(in Ray r)
{
    vec3 accum = vec3(0.0f);
    vec3 mask = vec3(1.0f);
    int nb_refl = 2; // Bounce number
    float c_refl = 1.0f;
    Ray curr_ray = r;
    for(int i = 0 ; i &lt;= nb_refl ; i++)
    {
        ISObj io = intersectObjects(curr_ray);
        if(io.t &gt;= 0)
        {
            PBRMat mat = pbr_mat[io.i];

            HitSurface hs = HitSurface(curr_ray.ro + io.d*curr_ray.rd, computeNormal(io,curr_ray),mat);               

            vec3 color = directIllumination(hs,curr_ray,c_refl);
            accum = accum + mask * color;
            mask = mask*c_refl;
            curr_ray  = Ray(hs.hit_point + 0.001*hs.normal,reflect(curr_ray.rd,hs.normal));
        }
        else
        {
            break;
        }
    }

    return accum;

}
</code></pre>
<p>Inside the directIllumination function, we iterate through each light of the scene and determine if the current intersection point is in the shadow of an object (which can be it self) by casting a ray in the direction of the light. If the intersection point is actually lighted, we compute its radiance inside the PBR function. Otherwise we assign an ambient color weighted by the ambient occlusion factor of the material. Finally we update the reflection intensity factor by computing the length of th Fresnel term.</p>
<pre><code>vec3 directIllumination(in HitSurface hit,in Ray r,inout float refl)
{

    vec3 color = vec3(0);
    for(int i = 0 ; i &lt; light_nbr ; i++)
    {
        Ray l_ray = lightRay(hit.hit_point,lights[i]);
        l_ray.ro = hit.hit_point + 0.001*hit.normal;
        ISObj io;
        io = intersectObjects(l_ray);
        float d_light = lightDist(hit.hit_point,lights[i]);

        if(io.t &lt; 0 || (io.t &gt;= 0 &amp;&amp; (io.d &gt;= d_light)))
        {
            color += PBR(hit,r,lights[i]);
        }
        else
        {
            color +=  vec3(0.03) * hit.material.color * hit.material.ao;
        }


        vec3 Ve = normalize(r.ro - hit.hit_point);
        vec3 H = normalize(Ve + l_ray.rd);
        refl = length(fresnelSchlick(max(dot(H, Ve), 0.0),  mix(vec3(0.04), hit.material.color, hit.material.metallic)))*hit.material.ao;
    }

    return color;
}

struct Light 
{
    int type; // 0 dir light, 1 point light
    vec3 dir; // directionnal light
    vec3 center; // point light
    float intensity; // 1 default
    vec3 color; // light color
};

Ray lightRay(in vec3 ro, in Light l) //computes ro to light source ray
{
    if(l.type == 0)
        return Ray(ro,normalize(l.dir));
    else if(l.type == 1)
        return Ray(ro,normalize(l.center - ro));

    return Ray(ro,vec3(1));
 }

float lightDist(in vec3 ro, in Light l) //computes distance to light
{ 
    if(l.type == 0)
         return DIST_MAX;
    else if(l.type == 1)
        return length(l.center - ro);

    return DIST_MAX;
}
</code></pre>
<p>Next, it is time to actually implement the PBR direct illumination function approximating the light equation.
This is done in two steps. We first compute the ambient term and the material $F_0$. We then compute the normal of the surface at the intersection point, the view vector, the half vector, the light intensity and direction and pass them to the computeReflectance function inside of which we compute the actual output radiance.</p>
<pre><code>vec3 PBR(in HitSurface hit, in Ray r , in Light l)
{
    vec3 ambient = vec3(0.03) * hit.material.color * hit.material.ao;
    //Average F0 for dielectric materials
    vec3 F0 = vec3(0.04);
    // Get Proper F0 if material is not dielectric
    F0 = mix(F0, hit.material.color, hit.material.metallic);
    vec3 N = normalize(hit.normal);
    vec3 Ve = normalize(r.ro - hit.hit_point);

    float intensity = 1.0f;
    if(l.type == 1)
    {
        float l_dist = lightDist(hit.hit_point,l);
        intensity = l.intensity/(l_dist*l_dist);
    }
    vec3 l_dir = lightRay(hit.hit_point,l).rd;
    vec3 H = normalize(Ve + l_dir);
    return ambient + computeReflectance(N,Ve,F0,hit.material.color,l_dir,H,l.color,intensity,hit.material.metallic,hit.material.roughness);
}
</code></pre>
<p>We then define all the BRDF functions we mentionned above:</p>
<pre><code>float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;

    float nom   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return nom / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return nom / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = GeometrySchlickGGX(NdotV, roughness);
    float ggx1  = GeometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
}

vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0)*pow((1.0 + 0.000001/*avoid negative approximation when cosTheta = 1*/) - cosTheta, 5.0);
}
</code></pre>
<p>Finally, we compute the outgoing radiance as the product of the incoming radiance, the BRDF terms and the dot product between the normal and the light direction.</p>
<pre><code>vec3 computeReflectance(vec3 N, vec3 Ve, vec3 F0, vec3 albedo, vec3 L, vec3 H, vec3 light_col, float intensity, float metallic, float roughness)
{
    vec3 radiance =  light_col * intensity; //Incoming Radiance

    // cook-torrance brdf
    float NDF = DistributionGGX(N, H, roughness);
    float G   = GeometrySmith(N, Ve, L,roughness);
    vec3 F    = fresnelSchlick(max(dot(H, Ve), 0.0), F0);

    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;

    vec3 nominator    = NDF * G * F;
    float denominator = 4 * max(dot(N, Ve), 0.0) * max(dot(N, L), 0.0) + 0.00001/* avoid divide by zero*/;
    vec3 specular     = nominator / denominator;


    // add to outgoing radiance Lo
    float NdotL = max(dot(N, L), 0.0);
    vec3 diffuse_radiance = kD * (albedo)/ PI;

    return (diffuse_radiance + specular) * radiance * NdotL;
}
</code></pre>
<p>And that&rsquo;s it, we set up everything to compute a more realistic shading of our scene, you can already produce new raytraced results using this setup.</p>
<p>Below, are rendering examples of the same scene with varying materials. It contains a single white point Light of intensity $I = 40$ and located at (0,0,0). Left to right spheres roughness are 1, 0.9, 0.7, 0.5, 0.3, 0.1 with (.1,.2,.8) as color and are located at (2.5,0,-2), (1.5,0,-2), (0.5,0,-2), (-0.5,0,-2), (-1.5,0,-2) and (-2.5,0,-2) with a radius of 0.3.</p>





  











<figure id="figure-dielectric-materials-without-reflection-metalness--0">


  <a data-fancybox="" href="/img/Images/PBR_Intro/dielec_no_refl.png" data-caption="Dielectric materials without reflection (metalness = 0)">


  <img src="/img/Images/PBR_Intro/dielec_no_refl.png" alt=""  >
</a>


  
  
  <figcaption>
    Dielectric materials without reflection (metalness = 0)
  </figcaption>


</figure>

<!-- <div style="width:image width px; font-size:100%; text-align:center;"><p align="center"> <img src="/Images/PBR_Intro/dielec_no_refl.png" alt="DielectNoRefl" style="width:700px;"/></p>Dielectric materials without reflection (metalness = 0)</div> -->





  











<figure id="figure-dielectric-materials-with-reflection-metalness--0">


  <a data-fancybox="" href="/img/Images/PBR_Intro/dielec_refl.png" data-caption="Dielectric materials with reflection (metalness = 0)">


  <img src="/img/Images/PBR_Intro/dielec_refl.png" alt=""  >
</a>


  
  
  <figcaption>
    Dielectric materials with reflection (metalness = 0)
  </figcaption>


</figure>

<!-- <div style="width:image width px; font-size:100%; text-align:center;"><p align="center"> <img src="/Images/PBR_Intro/dielec_refl.png" alt="DielectRefl" style="width:700px;"/></p>Dielectric materials with reflection (metalness = 0)</div> -->





  











<figure id="figure-metallic-materials-without-reflection-metalness--1">


  <a data-fancybox="" href="/img/Images/PBR_Intro/metal_no_refl.png" data-caption="Metallic materials without reflection (metalness = 1)">


  <img src="/img/Images/PBR_Intro/metal_no_refl.png" alt=""  >
</a>


  
  
  <figcaption>
    Metallic materials without reflection (metalness = 1)
  </figcaption>


</figure>

<!-- <div style="width:image width px; font-size:100%; text-align:center;"><p align="center"> <img src="/Images/PBR_Intro/metal_no_refl.png" alt="MetalNoRefl" style="width:700px;"/></p>Metallic materials without reflection (metalness = 1)</div> -->





  











<figure id="figure-metallic-material-with-reflection-metalness--1">


  <a data-fancybox="" href="/img/Images/PBR_Intro/metal_refl.png" data-caption="Metallic material with reflection (metalness = 1)">


  <img src="/img/Images/PBR_Intro/metal_refl.png" alt=""  >
</a>


  
  
  <figcaption>
    Metallic material with reflection (metalness = 1)
  </figcaption>


</figure>

<!-- <div style="width:image width px; font-size:100%; text-align:center;"><p align="center"> <img src="/Images/PBR_Intro/metal_refl.png" alt="MetalRefl" style="width:700px;"/></p>Metallic material with reflection (metalness = 1)</div> -->
<h2 id="one-last-step-hdr-and-gamma-correction-">One last step: HDR and Gamma correction</h2>
<p>So far we are able to render scenes in a more realistic way. Still, you can notice that if you choose a high intensity for your lights, the results also gets highly saturated, which is already the case in the above examples. This situation is to be expected because radiance can have value bigger than 1. Consequently, we need to find a way to account for High Dynamic Range (HDR) of radiance and process the computed values such that everything is remapped between 0 and 1. I won&rsquo;t enter into details here as it is not the subject of this tutorial. We basically use the Reinhard operator to correct our input colors, remapping them inside the $[0;1]^3$ space with the function $C = \frac{C}{C+1}$.</p>
<p>Finally, we also need to take into account the color shift that screens produce in response to color values and depending on what we call their gamma value defining this response. Hence, we proceed to a gamma correction of the output colors which rectifies the shift. Again this will be covered in another tutorial, however be careful that this gamma value depends on the monitor configuration you are using.</p>
<pre><code>vec3 trace()
{
    vec3 accum = vec3(0.0);
    ...

    //HDR
    accum = accum / (accum+ vec3(1.0));
    //Gamma
    float gamma = 2.2;
    accum = pow(accum, vec3(1.0/gamma));
}
</code></pre>
<p>Here are the corrected images of the previous examples with different gamma values.</p>





  











<figure id="figure-dielectric-materials-with-reflection-metalness--0-hdr-and-gamma--1">


  <a data-fancybox="" href="/img/Images/PBR_Intro/dielec_HDR_GAMMA_104.png" data-caption="Dielectric materials with reflection (metalness = 0) HDR and Gamma = 1">


  <img src="/img/Images/PBR_Intro/dielec_HDR_GAMMA_104.png" alt=""  >
</a>


  
  
  <figcaption>
    Dielectric materials with reflection (metalness = 0) HDR and Gamma = 1
  </figcaption>


</figure>

<!-- <div style="width:image width px; font-size:100%; text-align:center;"><p align="center"> <img src="/Images/PBR_Intro/dielec_HDR_GAMMA_104.png" alt="MetalRefl" style="width:700px;"/></p>Dielectric materials with reflection (metalness = 0) HDR and Gamma = 1</div> -->





  











<figure id="figure-dielectric-materials-with-reflection-metalness--0-hdr-and-gamma--22">


  <a data-fancybox="" href="/img/Images/PBR_Intro/dielec_HDR_GAMMA_2.png" data-caption="Dielectric materials with reflection (metalness = 0) HDR and Gamma = 2.2">


  <img src="/img/Images/PBR_Intro/dielec_HDR_GAMMA_2.png" alt=""  >
</a>


  
  
  <figcaption>
    Dielectric materials with reflection (metalness = 0) HDR and Gamma = 2.2
  </figcaption>


</figure>

<!-- <div style="width:image width px; font-size:100%; text-align:center;"><p align="center"> <img src="/Images/PBR_Intro/dielec_HDR_GAMMA_2.png" alt="MetalRefl" style="width:700px;"/></p>Dielectric materials with reflection (metalness = 0) HDR and Gamma = 2.2</div> -->





  











<figure id="figure-metallic-material-with-reflection-metalness--1-hdr-and-gamma--1">


  <a data-fancybox="" href="/img/Images/PBR_Intro/metal_HDR_GAMMA_104.png" data-caption="Metallic material with reflection (metalness = 1) HDR and Gamma = 1">


  <img src="/img/Images/PBR_Intro/metal_HDR_GAMMA_104.png" alt=""  >
</a>


  
  
  <figcaption>
    Metallic material with reflection (metalness = 1) HDR and Gamma = 1
  </figcaption>


</figure>

<!-- <div style="width:image width px; font-size:100%; text-align:center;"><p align="center"> <img src="/Images/PBR_Intro/metal_HDR_GAMMA_104.png" alt="MetalRefl" style="width:700px;"/></p>Metallic material with reflection (metalness = 1) HDR and Gamma = 1</div> -->





  











<figure id="figure-metallic-material-with-reflection-metalness--1-hdr-and-gamma--22">


  <a data-fancybox="" href="/img/Images/PBR_Intro/metal_HDR_GAMMA_2.png" data-caption="Metallic material with reflection (metalness = 1) HDR and Gamma = 2.2">


  <img src="/img/Images/PBR_Intro/metal_HDR_GAMMA_2.png" alt=""  >
</a>


  
  
  <figcaption>
    Metallic material with reflection (metalness = 1) HDR and Gamma = 2.2
  </figcaption>


</figure>

<!-- <div style="width:image width px; font-size:100%; text-align:center;"><p align="center"> <img src="/Images/PBR_Intro/metal_HDR_GAMMA_2.png" alt="MetalRefl" style="width:700px;"/></p>Metallic material with reflection (metalness = 1) HDR and Gamma = 2.2</div> -->
<p>You can also play with the different parameters and get various materials:</p>





  











<figure id="figure-various-materials-gamma--1">


  <a data-fancybox="" href="/img/Images/PBR_Intro/Final_Eg.png" data-caption="Various materials, Gamma = 1">


  <img src="/img/Images/PBR_Intro/Final_Eg.png" alt=""  >
</a>


  
  
  <figcaption>
    Various materials, Gamma = 1
  </figcaption>


</figure>

<!-- <div style="width:image width px; font-size:100%; text-align:center;"><p align="center"> <img src="/Images/PBR_Intro/Final_Eg.png" alt="FinalEg" style="width:700px;"/></p>Various materials, Gamma = 1</div> -->
<h2 id="and-then--whats-next--">And then ? What&rsquo;s Next ?</h2>
<p>Rendering is a huge topic and we covered a very small part of it. What is next entirely depends on which direction you want to pursue this journey; you could go into path tracing and ignore real-time approximations or on the contrary go for more real-time rendering effects like Image Based Lighting (IBL), Screen Space Ambient Occlusion (SSAO), Screen Space Reflections (SSR) and so on.</p>
<p>However, There is one aspect that should be improved in our current raytracing context which is the way we handle reflections. Indeed, currently in our ray-tracing context we cast only one reflected ray from intersection point. While it is accurate to do so for smooth surfaces, it is totally wrong for rough surfaces as we should cast several rays from the each intersection point and average the results in order to get the blurred reflections like I mentioned at the beginning of the tutorial. This is something you could try to implement in a naive manner and see how reflections are improved.
In addition, one can also questions the fact the presence of an ambient lighting term in this energy conservative context and he/she is right, this term is a complete hack to cope with the lack of indirect lighting computation. For real-time applications IBL can be used to better approximate this kind of lighting contribution while path tracing implicitly compute this contribution.</p>
<p>Finally, I want you to be aware that BRDF models are generalizable and can take into account more light dimensionality, in particular:</p>
<ul>
<li>BTDF: Bidirectionnal Transmission Distribution Function 5D: Same as BRDF for opposite side of surface</li>
<li>SVBRDF: Spatially Varying BRDF 6D: changes over the surface position</li>
<li>BSSRDF: Bidirectionnal Surface Scattering DF 8D: light exits at another location</li>
<li>BSDF: Bidirectionnal Scattering Distribution Function XD: General formulation</li>
</ul>
<h2 id="references-">References</h2>
<p>Open GL Tutorials: 
<a href="https://learnopengl.com/" target="_blank" rel="noopener">https://learnopengl.com/</a></p>
<p>Siggraph Courses: 
<a href="http://blog.selfshadow.com/publications/s2013-shading-course/" target="_blank" rel="noopener">http://blog.selfshadow.com/publications/s2013-shading-course/</a> 
<a href="http://blog.selfshadow.com/publications/s2014-shading-course/" target="_blank" rel="noopener">http://blog.selfshadow.com/publications/s2014-shading-course/</a></p>
<p>Real Time Rendering Advances: 
<a href="http://advances.realtimerendering.com/" target="_blank" rel="noopener">http://advances.realtimerendering.com/</a></p>
<p>BRDF Model Comparison: 
<a href="https://diglib.eg.org/handle/10.2312/EGWR.EGSR05.117-126" target="_blank" rel="noopener">https://diglib.eg.org/handle/10.2312/EGWR.EGSR05.117-126</a></p>
<p>Path tracing and Global Illumination: 
<a href="http://www.graphics.stanford.edu/courses/cs348b-01/course29.hanrahan.pdf" target="_blank" rel="noopener">http://www.graphics.stanford.edu/courses/cs348b-01/course29.hanrahan.pdf</a> 
<a href="http://web.cs.wpi.edu/~emmanuel/courses/cs563/write_ups/zackw/realistic_raytracing.html" target="_blank" rel="noopener">http://web.cs.wpi.edu/~emmanuel/courses/cs563/write_ups/zackw/realistic_raytracing.html</a></p>
<p>GLSL / Shadertoy: 
<a href="https://www.opengl.org/documentation/glsl/" target="_blank" rel="noopener">https://www.opengl.org/documentation/glsl/</a> 
<a href="https://www.shadertoy.com/" target="_blank" rel="noopener">https://www.shadertoy.com/</a> 
<a href="http://www.iquilezles.org/" target="_blank" rel="noopener">http://www.iquilezles.org/</a></p>

    </div>

    







<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=http://typhomnt.github.io/teaching/ray_tracing/pbr_intro/&amp;text=An%20Introduction%20to%20Physically%20Based%20Rendering" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=http://typhomnt.github.io/teaching/ray_tracing/pbr_intro/&amp;t=An%20Introduction%20to%20Physically%20Based%20Rendering" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=An%20Introduction%20to%20Physically%20Based%20Rendering&amp;body=http://typhomnt.github.io/teaching/ray_tracing/pbr_intro/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=http://typhomnt.github.io/teaching/ray_tracing/pbr_intro/&amp;title=An%20Introduction%20to%20Physically%20Based%20Rendering" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://web.whatsapp.com/send?text=An%20Introduction%20to%20Physically%20Based%20Rendering%20http://typhomnt.github.io/teaching/ray_tracing/pbr_intro/" target="_blank" rel="noopener" class="share-btn-whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://service.weibo.com/share/share.php?url=http://typhomnt.github.io/teaching/ray_tracing/pbr_intro/&amp;title=An%20Introduction%20to%20Physically%20Based%20Rendering" target="_blank" rel="noopener" class="share-btn-weibo">
          <i class="fab fa-weibo"></i>
        </a>
      </li>
    
  </ul>
</div>












  
  





  
    
    
    
      
    
    
    
    <div class="media author-card content-widget-hr">
      
        
        <img class="avatar mr-3 avatar-circle" src="/authors/admin/avatar_hu14fa9686a237893a821adc4e52dd5e2c_152507_270x270_fill_box_center_2.png" alt="">
      

      <div class="media-body">
        <h5 class="card-title"><a href="http://typhomnt.github.io/"></a></h5>
        <h6 class="card-subtitle">Post-Doc At Inria Rhone Alpes. Maverick Team</h6>
        <p class="card-text">My research interests include character animation and non-photorealistic rendering.</p>
        <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
    <li>
      <a href="mailto:maxime.garcia1@ensimag.grenoble-inp.fr" >
        <i class="fas fa-envelope"></i>
      </a>
    </li>
  
    
    
    
    
    
    
    
      
    
    <li>
      <a href="https://scholar.google.com/citations?user=HKRJSQoAAAAJ&amp;hl=en&amp;oi=sra" target="_blank" rel="noopener">
        <i class="ai ai-google-scholar"></i>
      </a>
    </li>
  
</ul>

      </div>
    </div>
  












  
  



  </div>
</article>

      

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/r.min.js"></script>
        
      

    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js" integrity="sha256-EErZamuLefUnbMBQbsEqu1USa+btR2oIlCpBJbyD4/g=" crossorigin="anonymous"></script>
    

    
    
    <script>const code_highlighting = true;</script>
    

    
    
    <script>const isSiteThemeDark = false;</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.37431be2d92d7fb0160054761ab79602.js"></script>

    






  
  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
